<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Path Follower - Stops</title>

    <!-- CSS Styles -->
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
            margin: 0;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .controls button {
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

        .size-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .size-control label {
            font-weight: bold;
            color: #555;
        }

        .size-control input[type="range"] {
            cursor: pointer;
        }

        .size-control span {
            min-width: 25px;
            text-align: right;
            font-family: monospace;
            color: #333;
        }

        .svg-container {
            border: 1px solid #ccc;
            background-color: #fff; /* Container background is white */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-width: 100%;
        }

        #motionSvg {
            display: block;
            max-width: 100%;
            height: auto;
            background-color: #fff; /* Explicitly set SVG background if needed */
        }

        /* Style for the visible path */
        #motionPath {
             stroke: #4a90e2; /* Changed to a visible blue color */
             stroke-width: 2;
             stroke-dasharray: 5 5;
             fill: none; /* Important: path should not be filled */
        }

        #followerRect {
            transition: width 0.1s linear, height 0.1s linear, x 0.1s linear, y 0.1s linear, opacity 0.3s ease-out;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>Rectangle Following SVG Path (Stops)</h1>

    <!-- Controls -->
    <div class="controls">
        <button id="togglePause">Pause</button> <!-- Will change text to Restart -->
        <button id="restartAnim">Restart</button>
        <div class="size-control">
            <label for="rectWidth">Width:</label>
            <input type="range" id="rectWidth" min="10" max="100" value="40">
            <span id="widthValue">40</span>px
        </div>
         <div class="size-control">
            <label for="rectHeight">Height:</label>
            <input type="range" id="rectHeight" min="10" max="100" value="20">
            <span id="heightValue">20</span>px
        </div>
    </div>

    <!-- SVG Area -->
    <div class="svg-container">
        <svg id="motionSvg" width="600" height="400" viewBox="0 0 600 400">
            <defs>
                <!-- Defs can be empty or contain other definitions -->
            </defs>

            <!-- The motion path, moved OUTSIDE <defs> to be rendered directly -->
            <path id="motionPath"
                  d="M 50 200 Q 150 50 300 200 T 550 200 C 580 350, 450 380, 300 300 S 50 250, 50 200 Z"
                  />
                  <!-- Styling is applied via CSS -->

            <!-- The rectangle that will follow the path -->
            <rect id="followerRect"
                  x="-20"
                  y="-10"
                  width="40"
                  height="20"
                  fill="dodgerblue"
                  stroke="black"
                  stroke-width="1"
                  style="opacity: 1;" /> <!-- Start visible -->
        </svg>
    </div>

    <!-- Anime.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <!-- JavaScript Code -->
    <script>
        class PathFollower {
            constructor(config) {
                // --- Element References ---
                this.svg = document.getElementById(config.svgId);
                this.path = document.getElementById(config.pathId);
                this.rect = document.getElementById(config.rectId);
                this.togglePauseBtn = document.getElementById(config.togglePauseBtnId);
                this.restartBtn = document.getElementById(config.restartBtnId);
                this.widthSlider = document.getElementById(config.widthSliderId);
                this.heightSlider = document.getElementById(config.heightSliderId);
                this.widthValueSpan = document.getElementById(config.widthValueId);
                this.heightValueSpan = document.getElementById(config.heightValueId);

                if (!this.svg || !this.path || !this.rect || !this.togglePauseBtn || !this.restartBtn || !this.widthSlider || !this.heightSlider || !this.widthValueSpan || !this.heightValueSpan) {
                    console.error("One or more elements not found. Check IDs.");
                    return;
                }

                // --- State ---
                this.isPaused = false;
                this.isCompleted = false; // Track if the single run is complete
                this.animation = null;

                // --- Initialization ---
                this._setInitialRectSize();
                this._createAnimation();
                this._setupEventListeners();
            }

            _setInitialRectSize() {
                const initialWidth = parseFloat(this.widthSlider.value);
                const initialHeight = parseFloat(this.heightSlider.value);
                this.updateWidth(initialWidth);
                this.updateHeight(initialHeight);
                this.widthValueSpan.textContent = initialWidth;
                this.heightValueSpan.textContent = initialHeight;
            }

            _createAnimation() {
                const pathMotion = anime.path(this.path);

                if (this.animation) {
                    anime.remove(this.rect);
                }

                this.animation = anime({
                    targets: this.rect,
                    translateX: pathMotion('x'),
                    translateY: pathMotion('y'),
                    rotate: pathMotion('angle'),
                    easing: 'linear',
                    duration: 5000,
                    loop: false, // *** CHANGED: Run only once ***
                    autoplay: true,
                    begin: (anim) => { // Runs at the very start of the animation
                        console.log("Animation beginning");
                        this.rect.style.opacity = 1; // Make sure it's visible
                        this.isPaused = false;
                        this.isCompleted = false; // Reset completed state on start/restart
                        this.togglePauseBtn.disabled = false; // Enable pause button
                        this.togglePauseBtn.textContent = 'Pause';
                    },
                    complete: (anim) => { // *** CHANGED: Runs only when loop: false and animation finishes ***
                        console.log("Animation fully complete");
                         this.isCompleted = true;
                         this.isPaused = true; // Treat as paused/stopped at the end
                         this.rect.style.opacity = 0; // Hide rectangle after completion
                         this.togglePauseBtn.textContent = 'Restart'; // Change button text
                         this.togglePauseBtn.disabled = false; // Keep button enabled for restart
                    }
                    // Removed loopComplete callback as loop is false
                });

                this.isPaused = !this.animation.autoplay;
                this.togglePauseBtn.textContent = this.isPaused ? 'Play' : 'Pause';
                if(this.animation.autoplay) {
                     this.rect.style.opacity = 1;
                } else {
                    // If not autoplaying, it's initially paused and potentially completed (if run before)
                    // Let's assume it starts fresh, so not completed yet if not autoplaying
                     this.isCompleted = false;
                     this.rect.style.opacity = 1; // Show if paused at start
                }
            }

            _setupEventListeners() {
                this.togglePauseBtn.addEventListener('click', this.togglePause.bind(this));
                this.restartBtn.addEventListener('click', this.restart.bind(this));
                this.rect.addEventListener('click', this.handleRectClick.bind(this));
                this.widthSlider.addEventListener('input', (e) => {
                    const newWidth = parseFloat(e.target.value);
                    this.updateWidth(newWidth);
                    this.widthValueSpan.textContent = newWidth;
                });
                this.heightSlider.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    this.updateHeight(newHeight);
                    this.heightValueSpan.textContent = newHeight;
                });
            }

            // --- Control Methods ---

            togglePause() {
                if (!this.animation) return;

                // If completed, pressing the button (now saying 'Restart') should restart
                if (this.isCompleted) {
                    this.restart();
                    return;
                }

                // Otherwise, toggle pause/play
                if (this.isPaused) {
                    this.animation.play();
                    this.togglePauseBtn.textContent = 'Pause';
                    this.rect.style.opacity = 1; // Ensure visible when playing
                } else {
                    this.animation.pause();
                    this.togglePauseBtn.textContent = 'Play';
                    // Don't change opacity on pause
                }
                this.isPaused = !this.isPaused;
                 this.togglePauseBtn.disabled = false; // Ensure enabled
                console.log("Animation paused:", this.isPaused);
            }

            restart() {
                if (!this.animation) return;

                console.log("Animation restarting");
                this.rect.style.opacity = 1; // Make visible before restarting
                this.isCompleted = false;
                this.isPaused = false;
                this.togglePauseBtn.disabled = false; // Ensure pause is enabled
                this.togglePauseBtn.textContent = 'Pause'; // Reset button text
                this.animation.restart(); // Restart the animation from the beginning
            }

            handleRectClick() {
                if (!this.animation) return;
                console.log("Rectangle clicked");
                // If completed (and hidden), clicking does nothing useful unless we restart
                // Let's make clicking restart it if completed
                if (this.isCompleted) {
                   console.log("Restarting via click on completed area");
                   this.restart();
                } else {
                    this.togglePause(); // Otherwise, just toggle pause/play
                }
            }

            updateWidth(newWidth) {
                this.rect.setAttribute('width', newWidth);
                this.rect.setAttribute('x', -newWidth / 2);
            }

            updateHeight(newHeight) {
                this.rect.setAttribute('height', newHeight);
                this.rect.setAttribute('y', -newHeight / 2);
            }
        }

        // --- Initialize after DOM is loaded ---
        let pathFollowerInstance = null;

        document.addEventListener('DOMContentLoaded', () => {
            pathFollowerInstance = new PathFollower({
                svgId: 'motionSvg',
                pathId: 'motionPath',
                rectId: 'followerRect',
                togglePauseBtnId: 'togglePause',
                restartBtnId: 'restartAnim',
                widthSliderId: 'rectWidth',
                heightSliderId: 'rectHeight',
                widthValueId: 'widthValue',
                heightValueId: 'heightValue'
            });
        });

        // --- Watcher Function ---
        function watchFollowerState() {
            if (pathFollowerInstance && pathFollowerInstance.animation) {
                let stateMessage = 'Initializing...';
                 // Check completion status FIRST
                if(pathFollowerInstance.isCompleted) {
                     stateMessage = 'Completed (Hidden & Stopped)';
                } else if (pathFollowerInstance.isPaused) {
                    stateMessage = 'Paused';
                } else if (!pathFollowerInstance.animation.paused) { // Check animation state directly too
                     stateMessage = 'Running';
                } else {
                     stateMessage = 'Starting/Unknown'; // Fallback
                }

                console.log(
                    `Watcher -> Status: ${stateMessage} | Paused Flag: ${pathFollowerInstance.isPaused} | Completed Flag: ${pathFollowerInstance.isCompleted}`
                );
            } else {
                console.log("Watcher -> PathFollower instance not ready yet.");
            }
        }

        setTimeout(() => {
             setInterval(watchFollowerState, 3000);
             console.log("Watcher started.");
        }, 500);

    </script>

</body>
</html>